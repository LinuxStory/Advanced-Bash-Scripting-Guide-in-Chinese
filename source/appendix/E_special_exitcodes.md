退出代码 | 表意 | 示例 | 注释
-------- | ---- | ---- |------
1 | 通用错误 | let "var1 = 1/0" | 其他错误，如除以零错误及其他无权限操作。
2 | (据 Bash 文档) 误用 Shell builtins | empty_function() {} | 缺失关键词或指令，或权限问题 (及 diff 在二进制文件比较时的返回值)
126 | 调用的指令无法执行 | /dev/null | 权限问题或命令不可执行
127 | 「未找到指令」 | illegal_command | 可能是 $PATH 有问题或输入有误。
128 | exit 的参数有误 | exit 3.14159 | exit 只接受范围在 0 - 255 的整数 (见第一个脚注)
128+n | 错误信号 “n” | 脚本的 kill -9 $PPID | $? 返回 137 (128 + 9)
130 | 脚本被 Control-C 终止 | Ctl-C | Control-C 是错误信号 2 (130 = 128 + 2, 见上)
255\* | 错误状态超范围 | exit -1 | exit 只接受范围在 0 - 255 的整数

根据上表，退出代码 1 - 2，126 - 165 及 255 有特别含义，并因此应避免用于用户定义的退出代码。以 *exit 127* 结束代码一定会在调试时导致混乱 (这是「命令未找到」的错误代码还是用户定义的？)。然而，许多脚本把 *exit 1* 当作出错通用退出指令。因为退出代码 1 表示许多可能的错误，这对调试不是很有用。

对此曾有过系统化退出代码的尝试 (见 `/usr/include/sysexits.h`)，但这是为了 C/C++ 程序员的。脚本中类似的标准可能比较恰当。文档作者提议限制用户定义的错误代码为 64 - 113 (包括表示成功的 0)，以符合 C/C++ 标准。这会分配 50 个可用代码，也会使脚本排错更直观。本文档中所有脚本示例符合这个标准，除了需要违反这一点的情况，如 例 9-2。

{% hint style="info" %}
只有在 Bash 或 *sh* 提示符中，Shell 脚本退出后在命令行执行 $? 才会给出与上表一致的结果，运行 *C-shell* 或 *tcsh* 有时会给出不同的结果。
{% endhint %}
